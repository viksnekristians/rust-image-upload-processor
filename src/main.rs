use axum::{
    routing::{get, post},
    Router,
    http::StatusCode,
    extract::Multipart,
};
use std::{sync::{Arc, Mutex}, thread};
use tokio::sync::mpsc;
use tokio::net::TcpListener;
use tokio::fs::File;
use tokio::io::AsyncWriteExt;
use rand::{distributions::Alphanumeric, Rng};
use image::ImageFormat;
use sqlx::mysql::MySqlPool;
use axum::extract::State;

async fn handler() -> StatusCode {
    println!("Received request");
    println!("Finished request");
    StatusCode::OK
}

async fn upload_image(mut multipart: Multipart, tx: Arc<mpsc::Sender<ImagePostUploadJob>>) -> StatusCode {
    while let Some(field) = multipart.next_field().await.unwrap() {
        println!("Received field: {:?}", field);
        let field_name = field.name().unwrap_or("unnamed").to_string();
        let original_file_name = field.file_name().map(|name| name.to_string()).unwrap_or("unknown".to_string());
        let extension = field.file_name()
            .and_then(|name| std::path::Path::new(name).extension())
            .and_then(|ext| ext.to_str())
            .unwrap_or("bin");
        let allowed_extensions = ["jpg", "jpeg", "png", "gif", "bmp", "webp"];
        let is_valid_image_ext = allowed_extensions.iter().any(|&ext| ext.eq_ignore_ascii_case(extension));
        let content_type = field.content_type().unwrap_or("application/octet-stream").to_string();

        if content_type.starts_with("image/") && is_valid_image_ext {
            let file_name = format!(
                "{}.{}",
                rand::thread_rng()
                    .sample_iter(&Alphanumeric)
                    .take(16)
                    .map(char::from)
                    .collect::<String>(),
                extension
            );
            println!("Processing image: {} ({})", file_name, content_type);
            // Read the entire field data into memory as bytes (async)
            let data = field.bytes().await.unwrap();
            let format = image::guess_format(&data);
            match format {
                Ok(fmt) => {
                    // Try to decode the image to ensure it's valid
                    if image::load_from_memory_with_format(&data, fmt).is_ok() {
                        println!("Valid image of format: {:?}", fmt);
                        // You can now process or save the image
                    } else {
                        println!("Invalid image data");
                        continue;
                    }
                }
                Err(_) => {
                    println!("Unknown or unsupported image format");
                    continue;
                }
            }
            // validate size etc?
            
            let dir = "uploads";
            // Get the project root (current working directory)
            let mut path = std::env::current_dir().unwrap();
            // Join the "uploads" directory
            path.push(dir);
            // Join the random filename
            path.push(&file_name);

            // Asynchronously create a new file at the specified path
            let mut file = File::create(&path).await.unwrap();

            // Asynchronously write the received bytes to the file
            file.write_all(&data).await.unwrap();

            let job = ImagePostUploadJob {
                id: rand::thread_rng().gen_range(1..1000), // real id should be generated by db
                file_name: file_name.clone(),
                dir: dir.to_string(),
            };
            tx.send(job).await.unwrap();
        } else {
            // If the field is not an image, log and skip it
            println!("Ignoring non-image field: {}", field_name);
        }
    }

    // Return HTTP 200 OK to the client after processing all fields
    StatusCode::OK
}

struct Worker {
    id: usize,
    thread: Option<thread::JoinHandle<()>>,
}

impl Worker {
    fn start(id: usize, receiver: Arc<Mutex<mpsc::Receiver<ImagePostUploadJob>>>) -> Self {
        let thread = thread::spawn(move || {
            println!("[Worker {}] started", id);
            loop {
                let job = {
                    let mut rx = receiver.lock().unwrap();
                    rx.blocking_recv()
                };
                if let Some(job) = job {
                    println!("[Worker {}] Processing job: {} {}", id, job.dir, job.file_name);
                    // Simulate thumbnail generation
                    job.generate_thumbnails();
                    println!("[Worker {}] Finished processing job: {}", id, job.file_name);
                } else {
                    println!("[Worker {}] No more jobs, exiting", id);
                    break;
                }
            }
        });
        Worker {id, thread: Some(thread)}
    }
}

struct ImagePostUploadJob {
    id: usize, // or what fields fits best for id? nullable mby?
    file_name: String,
    dir: String,
}
// impl- processeeshanas metode, ne?

impl ImagePostUploadJob {
    fn generate_thumbnails(&self) {
        // Placeholder for thumbnail generation logic
        println!("Generating thumbnails for {}", self.file_name);
        // Here you would typically use an image processing library to create thumbnails
    }
}

#[tokio::main]
async fn main() {
    let db_url = "mysql://rustuser:rustpass@localhost/image_processor";
    let db_pool = MySqlPool::connect(db_url).await.unwrap();
    // mpsc - multiple producer, single consumer
    let (tx, rx) = mpsc::channel::<ImagePostUploadJob>(100);
    // Arc is needed because Axum and workers are multi-threaded
    let tx = Arc::new(tx);
    let rx = Arc::new(Mutex::new(rx));

    // Start N workers - constant?
    let worker_count = 4;
    let mut workers = Vec::with_capacity(worker_count);

    for i in 0..worker_count {
        let rx = rx.clone();
        workers.push(Worker::start(i, rx));
    }

    // Build router with routes
    // build in a separate function?
    let app = Router::new()
        .route("/", get(handler))
        .route("/upload", post(
            {
                let tx = tx.clone();
                move |multipart: Multipart| upload_image(multipart, tx)
            }
        ));

    // Bind to address
    let listener = TcpListener::bind("127.0.0.1:3000").await.unwrap();
    println!("Listening on http://{}", listener.local_addr().unwrap());

    // could be worth understanding what happens under the hood more (async request handling)
    axum::serve(listener, app.into_make_service())
        .await
        .unwrap();
}